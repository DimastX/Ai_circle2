# AI Circle Simulation

Проект для моделирования движения транспортных средств по круговой дороге с использованием SUMO (Simulation of Urban MObility) и EIDM (Enhanced Intelligent Driver Model). Проект включает в себя различные сценарии моделирования, включая анализ пробок, теорию пробок и управление переменными скоростными ограничениями (VSL).

## Структура проекта

```
.
├── config/
│   ├── network/     # Файлы сети (circle.net.xml, circle.nod.xml, circle.edg.xml)
│   └── routes/      # Файлы маршрутов (генерируются автоматически)
│   └── vsl_config.yml # Конфигурационный файл для VSL контроллера
├── data/            # Может использоваться для хранения специфичных данных сценариев (не результатов)
├── results/         # Директория для всех результатов симуляций и анализа
│   └── run_XXXX/    # Конкретная директория запуска симуляции
│       ├── analysis_plots_YYYY/ # Графики и JSON из analyze_circle_data.py
│       ├── fcd_output_...csv    # FCD данные от SUMO
│       ├── V_data_detectors.npy # Данные о скорости с детекторов
│       ├── N_data_detectors.npy # Данные о количестве ТС с детекторов
│       ├── Q_data_detectors.npy # Данные о потоке с детекторов
│       ├── rho_data_detectors.npy# Данные о плотности с детекторов
│       ├── cameras_coords.npy   # Координаты детекторов
│       ├── Ts_detector.txt      # Период опроса детекторов
│       ├── rt_detected_wave_events.csv # События волн, обнаруженные в реальном времени
│       └── vsl_log.csv          # Лог работы VSL контроллера (если включено)
├── ring_files/      # Файлы для кольцевой дороги (например, add_detectors.xml)
├── src/
│   ├── __init__.py
│   ├── run_circle_simulation.py   # Главный скрипт запуска симуляций с детекторами
│   ├── analyze_circle_data.py    # Скрипт анализа данных FCD и детекторов
│   ├── eidm_stability_analysis.py# Теоретический анализ устойчивости и вызов симуляций
│   ├── traci_interaction.py      # Модуль для взаимодействия с TraCI и RealTimeWaveDetector
│   ├── vsl_controller.py         # Модуль VSL контроллера
│   ├── generate_circle_rou_new.py  # Генератор маршрутов (может быть устаревшим)
│   ├── run_circle.py              # Старый скрипт запуска симуляции (без детекторов)
│   ├── analyze_data.py           # Старый скрипт анализа данных
│   ├── new_breakdown.py          # Моделирование пробок (базовая версия, может быть устаревшим)
│   ├── new_breakdown_N.py        # Моделирование пробок (расширенная версия, может быть устаревшим)
│   ├── theory_breakdown.py       # Теоретический анализ пробок (может быть устаревшим)
│   └── circle_gen.py             # Генератор кольцевой дороги (может быть устаревшим)
└── requirements.txt # Зависимости проекта
```
(Некоторые старые скрипты в `src/` могут быть неактуальны или заменены новой логикой в `run_circle_simulation.py`, `analyze_circle_data.py` и `eidm_stability_analysis.py`)

## Установка

1. Установите SUMO (Simulation of Urban MObility):
   - Windows: Скачайте и установите с [официального сайта](https://sumo.dlr.de/docs/Installing/Windows.html)
   - Linux: `sudo apt-get install sumo`

2. Установите зависимости проекта:
   ```bash
   pip install -r requirements.txt
   ```

## Использование

Основной рабочий процесс теперь сосредоточен вокруг `src/eidm_stability_analysis.py` для теоретического анализа и запуска серий симуляций, или `src/run_circle_simulation.py` для запуска отдельных симуляций с детекторами.

### Запуск одиночной симуляции с детекторами и анализом
1. Запуск симуляции (пример):
   ```bash
   cd src
   python run_circle_simulation.py --num-vehicles 77 --sumo-binary path/to/sumo-gui.exe --simulation-duration 1800
   ```
   (Или `sumo.exe` для CLI)
   Это создаст директорию в `results/` с именем, включающим параметры и временную метку. Внутри будут FCD CSV, данные детекторов (`.npy`, `.txt`) и `rt_detected_wave_events.csv`.

2. Анализ результатов:
   ```bash
   cd src
   python analyze_circle_data.py --results-dir path/to/results/run_XXXX --warmup-time 150
   ```
   Это создаст поддиректорию `analysis_plots_YYYY` внутри `run_XXXX` с графиками и `analysis_summary.json`.

### Запуск симуляции с VSL контроллером

VSL контроллер может быть запущен как самостоятельный скрипт (для тестирования или отдельных сценариев) или интегрирован в существующий симуляционный скрипт.

1.  **Как самостоятельный скрипт**:
    ```bash
    python -m src.vsl_controller --net config/network/circle.net.xml --routes config/routes/generated.rou.xml --vsl
    ```
    Ключевые аргументы командной строки:
    *   `--config`: Путь к `.sumocfg` файлу SUMO.
    *   `--net`: Путь к файлу сети (`.net.xml`).
    *   `--routes`: Путь к файлу маршрутов (`.rou.xml`).
    *   `--sumo-bin`: Путь к исполняемому файлу SUMO (`sumo-gui` или `sumo`). По умолчанию `sumo`.
    *   `--duration`: Длительность симуляции в секундах. По умолчанию `3600`.
    *   `--nogui`: Запуск SUMO без GUI. По умолчанию `False` (с GUI).
    *   `--vsl`: Включить VSL контроллер. По умолчанию `False`.
    *   `--vsl-config`: Путь к YAML файлу конфигурации VSL контроллера. По умолчанию `vsl_config.yml` в корне проекта.

2.  **Интеграция в существующий скрипт**:
    Предполагается, что ваш основной симуляционный скрипт имеет главный цикл. Вы можете импортировать и использовать `VSLController` следующим образом:

    ```python
    # В вашем основном скрипте симуляции
    import traci
    from src.vsl_controller import VSLController, Config  # Убедитесь, что src в PYTHONPATH

    # ... ваш код инициализации TraCI ...

    # Пример получения флага --vsl из аргументов
    # import argparse
    # parser = argparse.ArgumentParser()
    # parser.add_argument('--vsl', action='store_true', help='Enable VSL controller')
    # args = parser.parse_args()
    # vsl_enabled_by_flag = args.vsl

    vsl_enabled_by_flag = True # или False, в зависимости от вашей логики

    if vsl_enabled_by_flag:
        vsl_config_path = "vsl_config.yml" # Путь к вашему конфиг файлу
        vsl_cfg = Config(vsl_config_path)
        vsl_controller = VSLController(traci, vsl_cfg, enabled=True)
    else:
        vsl_controller = None

    simulation_time = 0
    step_length = 0.1 # Ваш шаг симуляции

    while simulation_time < SIMULATION_DURATION:
        traci.simulationStep()
        simulation_time += step_length

        if vsl_controller and vsl_controller.is_enabled():
            vsl_controller.step(simulation_time)

        # ... остальная логика вашего шага симуляции ...

    # ... ваш код завершения TraCI ...
    ```

### Конфигурация VSL (`vsl_config.yml`)

Файл `vsl_config.yml` (по умолчанию создается с настройками по умолчанию, если не существует) содержит параметры для VSL контроллера. Пример:

```yaml
v0: 20.0           # Желаемая скорость (м/с) из IDM, также начальная скорость для VSL
T: 1.5             # Желаемое время следования (с) из IDM
a: 1.0             # Максимальное ускорение (м/с^2) из IDM
b: 1.5             # Комфортное торможение (м/с^2) из IDM
s0: 2.0            # Минимальный зазор (м) из IDM
delta: 4           # Экспонента ускорения из IDM
l_veh: 5.0         # Длина транспортного средства (м)

camera_dx: 100.0    # Длина зоны детектирования "камеры" (м)
camera_lanes:       # Список ID полос для "камеры-0"
  - "E0_0"
ctrl_segments:     # Список ID полос для применения VSL
  - "E0_0"
Ts: 5.0             # Шаг управления VSL (с)
Kp: 0.1
Ki: 0.01
Kd: 0.0
v_min: 5.0          # Минимальная скорость для VSL (м/с)
rho_crit: 0.02      # Целевая/критическая плотность (авт/м), может быть 'auto' для расчета
log_csv: "vsl_log.csv" # Имя CSV файла для логгирования (относительно директории results/run_XXXX/)
hot_reload_interval: 60 # Интервал горячей перезагрузки конфига (с)
```
Основные параметры:
*   Параметры IDM (`v0, T, a, b, s0, delta, l_veh`): Используются для расчета $\rho_{crit}$ (если 'auto') и как базовые значения.
*   `camera_dx`, `camera_lanes`: Определяют зону, где собираются данные о потоке (количество машин $N$, средняя скорость $\bar{v}$).
*   `ctrl_segments`: Полосы, на которых устанавливаются ограничения скорости VSL.
*   `Ts`: Периодичность работы алгоритма VSL (сбор данных, расчет, применение нового $v_{VSL}$).
*   `Kp, Ki, Kd`: Коэффициенты ПИД-регулятора.
*   `v_min`: Минимальное значение скорости, которое может установить VSL.
*   `rho_crit`: Целевая плотность. Если установлено в `'auto'`, рассчитывается на основе параметров IDM при инициализации. (Примечание: текущая реализация `vsl_controller.py` может использовать упрощенный расчет $\rho_{crit}$ или требовать его явного задания).
*   `log_csv`: Имя файла для записи логов работы VSL (например, `sim_time, rho, error, v_vsl, control_action_u`). Файл сохраняется в директорию результатов текущего запуска симуляции.
*   `hot_reload_interval`: Как часто (в секундах) скрипт будет проверять изменения в YAML файле конфигурации и перезагружать их без остановки симуляции.

### Теоретический анализ устойчивости и пакетный запуск симуляций
Смотрите раздел "Анализ устойчивости и сравнение с SUMO (eidm_stability_analysis.py)".

## Параметры симуляции (для `run_circle_simulation.py`)

- `--num-vehicles`: Количество автомобилей.
- `--simulation-duration`: Длительность симуляции в секундах.
- `--sumo-binary`: Путь к `sumo-gui.exe` или `sumo.exe`.
- `--config-name`: Имя конфигурации (влияет на имя директории результатов).
- `--detector-spacing`: Расстояние между детекторами (м).
- `--detector-sampling-period`: Период опроса детекторов (с).
- Другие параметры IDM могут быть заданы как константы в скрипте или переданы через аргументы, если реализовано.

## Результаты

### Результаты симуляции
Результаты каждой симуляции, запущенной через `run_circle_simulation.py` или `eidm_stability_analysis.py`, сохраняются в уникальной поддиректории внутри `results/`. Эти данные включают:
- `fcd_output_*.csv`: Данные о траекториях транспортных средств (Floating Car Data).
- `V_data_detectors.npy`: Матрица средних скоростей с каждого детектора за каждый период опроса.
- `N_data_detectors.npy`: Матрица количества ТС, прошедших через каждый детектор за каждый период опроса.
- `Q_data_detectors.npy`: Матрица интенсивности потока (ТС/с) для каждого детектора.
- `rho_data_detectors.npy`: Матрица плотности потока (ТС/м) для каждого детектора.
- `cameras_coords.npy`: NumPy массив с координатами каждого детектора на кольце.
- `Ts_detector.txt`: Файл, содержащий значение периода опроса детекторов `Ts`.
- `rt_detected_wave_events.csv`: CSV файл с информацией о волнах stop-and-go, обнаруженных в реальном времени модулем `RealTimeWaveDetector` во время симуляции. Содержит `t_event_s`, `x_event_m`, `wave_speed_mps` и др.
- `additional.xml`: Файл с описанием детекторов, сгенерированный для SUMO.
- `*.sumocfg`, `*.rou.xml`: Конфигурационные файлы SUMO для данного запуска.

### Результаты анализа
Скрипт `analyze_circle_data.py` обрабатывает данные из директории результатов симуляции и создает поддиректорию `analysis_plots_YYYY`, содержащую:
- `spacetime_heatmap_fcd_rt_annotated.png`: Пространственно-временная тепловая карта скорости `V(x,t)`, построенная по FCD данным. На эту карту нанесены вертикальные пунктирные линии, отмечающие моменты времени обнаружения stop-and-go волн (`t_event_s`) из `rt_detected_wave_events.csv` (с учетом `warmup_time`).
- `rhot_profile_detectors_annotated.png`: График зависимости плотности `rho(t)` от времени для первого детектора, также с аннотациями `rt_wave_event_times`.
- Стандартные графики на основе FCD:
    - `velocity_time_all.png` (V(t) для всех ТС)
    - `distance_time_all.png` (S(t) для всех ТС)
    - `velocity_position_all.png` (V(x) для всех ТС)
    - `fft_mean_speed.png` (Амплитудный спектр Фурье средней скорости)
    - И другие варианты этих графиков (для выбранных ТС и т.д.)
- `analysis_summary.json`: Сводка анализа, включая метрику `waves_observed` (основанную на стандартном отклонении скорости из FCD) и другие параметры.

Функция `detect_stop_and_go_waves` в `eidm_stability_analysis.py` предназначена для более детального анализа данных с детекторов (включая N, V, Q, rho) с целью обнаружения волн и может генерировать файл `detected_wave_events_from_postprocessing.csv`. Однако, её интеграция для автоматической аннотации всех графиков в `analyze_circle_data.py` на данный момент ограничена (большая часть соответствующего кода закомментирована в пользу использования `rt_detected_wave_events.csv`).

## Анализ устойчивости и сравнение с SUMO (eidm_stability_analysis.py)

Скрипт `src/eidm_stability_analysis.py` предназначен для проведения теоретического анализа устойчивости транспортного потока, описываемого моделью IDM (Intelligent Driver Model), и опционального сравнения теоретических предсказаний с результатами симуляций в SUMO для кольцевой дороги.

### Запуск

```bash
# Только теоретический анализ
python src/eidm_stability_analysis.py

# Теоретический анализ + запуск симуляций SUMO для сравнения
python src/eidm_stability_analysis.py --run-sumo-simulations --sumo-binary /path/to/sumo-gui.exe --sumo-tools-dir /path/to/sumo/tools
```

### Функционал

1.  **Теоретический анализ:**
    *   Находит равновесные состояния (скорость `v_e`, чистый зазор `s_e_net`) для различных условий (например, для заданного потока `Q`).
    *   Вычисляет частные производные IDM (`f_s`, `f_dv`, `f_v`) в точках равновесия.
    *   Определяет устойчивость взвода (platoon stability).
    *   Определяет устойчивость потока (string stability) с помощью критерия `K = f_v²/2 - f_dv*f_v - f_s`.
    *   Генерирует графики, иллюстрирующие:
        *   Фундаментальную диаграмму (v* от s*_net).
        *   Зависимость производных и критерия K от скорости.
        *   Области устойчивости взвода и потока.
        *   Влияние параметров IDM (например, времени реакции `T`) на устойчивость при фиксированных условиях (например, потоке `Q`).

2.  **Интеграция с SUMO (при флаге `--run-sumo-simulations`):**
    *   Для выбранного сценария (например, варьирование `T` при фиксированном `Q`):
        *   Для каждого теоретического равновесного состояния (`v_e`, `s_e_net`) рассчитывает необходимое количество машин `N` для кольца фиксированной длины.
        *   **Вызывает `src/run_circle_simulation.py`:** Запускает симуляцию SUMO. Этот скрипт:
            *   Подготавливает конфигурационные файлы SUMO (модифицируя `.rou.xml` и `.sumocfg`).
            *   Генерирует `additional.xml` для расстановки детекторов на кольце.
            *   Запускает симуляцию с использованием `src/traci_interaction.py`.
            *   Во время симуляции, `RealTimeWaveDetector` из `traci_interaction.py` анализирует данные с детекторов и записывает обнаруженные волны в `rt_detected_wave_events.csv`.
            *   По завершении сохраняет FCD данные в CSV, а также данные со всех детекторов (V, N, Q, rho, координаты, Ts) в отдельные файлы (`.npy`, `.txt`).
        *   **Вызывает `src/analyze_circle_data.py`:** Анализирует полученные FCD данные и данные детекторов из директории результатов. Этот скрипт:
            *   Вычисляет метрики (например, стандартное отклонение скорости из FCD для флага `waves_observed`).
            *   Строит графики (см. раздел "Результаты анализа"), включая FCD тепловую карту и `rho(t)` с аннотациями из `rt_detected_wave_events.csv`.
            *   Сохраняет сводку анализа в `analysis_summary.json`.
        *   **Считывает `analysis_summary.json`:** Извлекает результат симуляции (`waves_observed` на основе FCD).
    *   **Сравнение:** Перерисовывает теоретический график устойчивости (например, T vs Устойчивость потока), добавляя на него точки, полученные из симуляций SUMO, помеченные как стабильные или нестабильные (на основе `waves_observed` из FCD). Данные из `rt_detected_wave_events.csv` дают дополнительное, более прямое подтверждение наличия волн, которое отображается на графиках анализа.
