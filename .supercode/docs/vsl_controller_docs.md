# Документация по `src/vsl_controller.py`

## Общее описание

Этот модуль реализует логику контроллера VSL (Variable Speed Limits - Управление Переменными Скоростными Ограничениями). Контроллер предназначен для работы в связке с симулятором SUMO через TraCI с целью улучшения характеристик транспортного потока, например, для предотвращения или смягчения stop-and-go волн.

Основные задачи:

1.  **Инициализация контроллера**:
    *   Принимает соединение TraCI, параметры модели IDM (для справки или расчетов), список управляемых сегментов/полос, интервал управления, коэффициенты ПИД-регулятора (хотя используется в основном ПИ), целевую критическую плотность и другие параметры.
    *   Сохраняет начальные ограничения скорости на управляемых сегментах.
    *   Настраивает логирование своих действий в CSV файл.
2.  **Цикл управления** (вызывается на каждом шаге симуляции из `run_circle_simulation.py`):
    *   С определенным интервалом (`ts_control_interval`):
        *   Считывает данные (скорость, количество ТС) с назначенного ему детектора VSL через TraCI.
        *   Рассчитывает текущую плотность потока на этом детекторе.
        *   Вычисляет ошибку как разницу между текущей плотностью и целевой критической плотностью (`rho_crit_target`).
        *   Использует ПИ-регулятор (пропорциональный и интегральный компоненты) для расчета изменения скорости (`delta_v_limit`).
        *   Рассчитывает новое ограничение скорости, корректируя предыдущее на `delta_v_limit`.
        *   Ограничивает новое скоростное ограничение минимальным (`v_min_vsl_limit`) и максимальным (начальное ограничение скорости на данном участке или `idm_v0_default`) значениями.
        *   Применяет новое ограничение скорости к указанным полосам (`ctrl_segments_lanes`) через TraCI.
    *   Логирует текущее состояние (время, плотность, ошибка, новое ограничение скорости и т.д.) в CSV файл.
3.  **Вспомогательные функции**:
    *   Может содержать функции для расчета частных производных IDM (например, `compute_idm_partials`), но в текущей реализации они не используются активно самим контроллером VSL.

## Ключевые классы и функции

-   **`class VSLController`**:
    *   `__init__(...)`: Конструктор, инициализирует параметры, ПИ-регулятор, логирование.
    *   `_store_and_apply_initial_speeds()`: Сохраняет и применяет начальные ограничения скорости.
    *   `_setup_logging()`: Настраивает CSV-логгер.
    *   `step(sim_time)`: Основной метод, выполняющий цикл управления.
    *   `toggle(enabled, sim_time)`: Позволяет включать/выключать контроллер во время симуляции.
    *   `close_log()`: Закрывает файл лога.
-   **`compute_idm_partials`**: Функция для расчета частных производных функции ускорения IDM (кажется, не используется контроллером напрямую, но может быть полезна для анализа или других целей).

## Внешние зависимости (ключевые импорты)

-   **Стандартные библиотеки Python**:
    *   `csv`
    *   `datetime`
    *   `logging`
    *   `math`
    *   `typing` (`List`, `Tuple`, `Dict`, `Optional`, `Any`)
-   **Сторонние библиотеки (из `requirements.txt`)**:
    *   `numpy` (неявно, если используется в `traci_interaction` или при обработке данных)
-   **SUMO (TraCI)**:
    *   `traci` (передается как аргумент `traci_conn` в конструктор)
    *   `traci.constants`
-   **Внутренние модули проекта**:
    *   Косвенно зависит от `src/traci_interaction.py` для получения данных, если функции TraCI не вызываются напрямую.

## Взаимодействие с другими компонентами

-   Экземпляр `VSLController` создается и используется в `src/run_circle_simulation.py`, если активирован режим VSL.
-   `run_circle_simulation.py` передает ему активное соединение `traci` и вызывает его метод `step()` на каждом шаге симуляционного цикла.
-   Контроллер читает данные с детекторов и изменяет ограничения скорости на полосах, взаимодействуя с SUMO через TraCI.
-   Логирует свою работу в `vsl_controller_log.csv`, который может быть проанализирован отдельно или вместе с другими результатами симуляции (например, в `analyze_circle_data.py`, хотя текущая версия `analyze_circle_data.py` явно не анализирует этот лог).

## Основной сценарий использования

1.  `run_circle_simulation.py` (при наличии флага `--vsl` и параметров `--vsl-params-json`):
    *   Инициализирует `VSLController`, передавая ему конфигурацию (ID детектора, управляемые полосы, параметры ПИ-регулятора, целевую плотность и т.д.) и активное соединение `traci`.
    *   В основном цикле симуляции вызывает метод `controller.step(current_sim_time)`.
2.  `VSLController.step()`:
    *   Проверяет, наступило ли время для очередного управляющего воздействия.
    *   Если да, получает данные с детектора.
    *   Рассчитывает новую плотность и ошибку относительно `rho_crit_target`.
    *   Вычисляет новое ограничение скорости с помощью ПИ-алгоритма.
    *   Применяет новое ограничение скорости через `traci.lane.setMaxSpeed()`.
    *   Записывает данные в лог.

## Ключевые структуры данных и файлы

-   **`VSLController` атрибуты**:
    *   `self.integral_error`: Интегральная составляющая ошибки для ПИ-регулятора.
    *   `self.previous_error`: Предыдущая ошибка (для D-компонента, если бы он использовался).
    *   `self.current_speed_limit_mps`: Текущее установленное ограничение скорости.
    *   `self.log_writer`, `self.log_file`: Для записи CSV-лога.
-   **Выходные файлы**:
    *   `vsl_controller_log.csv`: Содержит временные ряды данных о работе контроллера (время, целевая плотность, измеренная плотность, ошибка, управляющее воздействие, установленное ограничение скорости).

## Конфигурация и параметры

Конфигурация `VSLController` передается из `run_circle_simulation.py` через JSON-строку (`--vsl-params-json`), которая парсится и передается в конструктор контроллера. Ключевые параметры:

-   `idm_v0_default`: Начальная/максимальная желаемая скорость (м/с).
-   `ctrl_segments_lanes`: Список ID полос, на которые распространяется управление.
-   `ts_control_interval`: Интервал времени (с) между управляющими воздействиями.
-   `kp`, `ki`, `kd`: Коэффициенты ПИД-регулятора (в текущей реализации kd не используется).
-   `v_min_vsl_limit`: Минимально допустимое ограничение скорости (м/с).
-   `rho_crit_target`: Целевая критическая плотность (ТС/км), к которой стремится контроллер.
-   `vsl_detector_id`: ID детектора, данные с которого используются для обратной связи.
-   `vsl_detector_length_m`: Длина этого детектора (м).
-   `log_csv_filename`: Имя файла для лога (полный путь формируется в `run_circle_simulation.py`).
-   `sim_step_length`: Длительность одного шага симуляции SUMO (с).

## Замечания и возможные улучшения

-   Текущая реализация использует ПИ-регулятор. Включение D-компонента (производной ошибки) может улучшить реакцию и стабильность контроллера.
-   Логика расчета `rho_crit_target` вынесена в `eidm_stability_analysis.py` (функция `compute_rho_crit`) и передается как параметр. Это хорошее разделение ответственности.
-   Эффективность контроллера сильно зависит от правильного выбора его параметров (коэффициентов ПИ, `rho_crit_target`, интервала управления) и расположения детектора VSL.
-   Возможно, стоит рассмотреть более сложные алгоритмы управления, кроме ПИД. 